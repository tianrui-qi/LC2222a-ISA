## Requirements

### CircuitSim

We use [CircuitSim](https://ra4king.github.io/CircuitSim/) version `1.9.1` to 
inplement the datapath and simulate the assembly. For Windows user, go to 
[CircuitSim/Windows/](https://www.roiatalla.com/public/CircuitSim/Windows/) to 
download and install the `.exe` file.
For MacOS, the installation is a little bit tricky. First, download the Jar file
from [CircuitSim/Jar/](https://www.roiatalla.com/public/CircuitSim/Jar/). 
CircuitSim requires Java 14+. Additionally, not all versions of the JDK come 
with JavaFX which CircuitSim uses. 
-   If you have never installed Java 14 or higher before, simply install the 
    latest JDK that already comes with JavaFX, i.e., 
    [Azul Zulu](https://www.azul.com/downloads/?os=macos&package=jdk-fx#downloads-table-zulu).
    To open CircuitSim,
    ```shell
    java -jar "CircuitSim1.9.1.jar"
    ```
-   If you already have a recent Java version installed, download the JavaFX SDK
    separately from [Gluon JavaFX](https://gluonhq.com/products/javafx/) that 
    matches your Java version. To open CircuitSim,
    ```shell
    java -jar --module-path "javafx-sdk-21.0.4/lib" --add-modules javafx.base,javafx.controls,javafx.fxml "CircuitSim1.9.1.jar"
    ```
Note that you need to replace `javafx-sdk-21.0.4` and `CircuitSim1.9.1.jar`
with the correct path to the JavaFX SDK and the CircuitSim jar. Then, click 
File -> Load to check our [datapath.sim](datapath.sim) file.

### Assembly

The LC-2222 assembler is written in Python. If you do not have Python 2.6 or 
newer installed on your system, you will need to install it before you continue.

## Datapath

![00-Datapath](assets/00-Datapath.png)

## Registers

### Registers and their Uses

The LC-2222a has 16 general-purpose registers:

| Register Number | Name  | Use                         | Callee Save? |
|-----------------|-------|-----------------------------|--------------|
| 0               | $zero | Always Zero                 | NA           |
| 1               | $at   | Assembler/Target Address    | NA           |
| 2               | $v0   | Return Value                | No           |
| 3               | $a0   | Argument 1                  | No           |
| 4               | $a1   | Argument 2                  | No           |
| 5               | $a2   | Argument 3                  | No           |
| 6               | $t0   | Temporary Variable          | No           |
| 7               | $t1   | Temporary Variable          | No           |
| 8               | $t2   | Temporary Variable          | No           |
| 9               | $s0   | Saved Register              | Yes          |
| 10              | $s1   | Saved Register              | Yes          |
| 11              | $s2   | Saved Register              | Yes          |
| 12              | $k0   | Reserved for OS and Traps   | NA           |
| 13              | $sp   | Stack Pointer               | No           |
| 14              | $fp   | Frame Pointer               | Yes          |
| 15              | $ra   | Return Address              | No           |

-   **Register 0** is always read as zero. Any values written to it are 
    discarded. 
-   **Register 1** is used to hold the target address of a jump. It may also be 
    used by pseudo-instructions generated by the assembler.
-   **Register 2** is where you should store any returned value from a 
    subroutine call.
-   **Register 3-5** are used to store function/subroutine arguments. 
-   **Register6-8** are designated for temporary variables. The caller must 
    save these registers if they want these values to be retained.
-   **Register 9-11** are saved registers. The caller may assume that these 
    registers are never tampered with by the subroutine. If the subroutine needs 
    these registers, then it should place them on the stack and restore them 
    before they jump back to the caller.
-   **Register 12** is reserved for handling interrupts. While it should be 
    implemented, it otherwise will not have any special use on this assignment.
-   **Register 13** is the everchanging top of the stack; it keeps track of the 
    top of the activation record for a subroutine.
-   **Register 14** is the anchor point of the activation frame. It is used to 
    point to the first address on the activation record for the currently 
    executing process.
-   **Register 15** is used to store the address a subroutine should return to 
    when it is finished executing.

### Implementation

At implementation level, registers has a 32-bit input data `Din`, a 32-bit 
output data `Dout`, and three control signals: `WrREG`, `regno`, `Clock`. Since 
we only have 16 registers, we use a 4-bit `regno` to select which register to 
read or write.

-   **Write Register.** When write data into a register, set `WrREG` to `1` and 
    `regno` to the register that we want to write to. Note that in 
    our design we use a decode with 5-bit select signal where the first 4 bits 
    are the `regno` and the last bit is not of `WrREG` and . When `WrREG` is 
    `0`, the decoder will always select `[16-19]`, i.e., no register will be 
    enabled to write. When `WrREG` is `1`, the decoder will select by the 
    `regno` value.
-   **Read Register.** We use two levels of Mux with 2-bit select signal two 
    select which register to read. The first level Mux selects using `regno[0-1]`
    and the second level Mux selects using `regno[2-3]`. As a notes, for our 
    implementation of register, there is not gate inside that control whether to
    output the data or not. We put the gate at the main datapath `DrREG`.

![04-Registers](assets/04-Registers.png)

## Insturction

## Microcontrol

![07-Microcontroller](assets/07-Microcontroller.png)
![microcode](assets/microcode.png)
